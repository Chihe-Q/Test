what  	how	why（为什么要用它，有几种方案，最佳方案）	contect(联系)	different(不同)

# 自我介绍

面试官你好，非常荣幸参加这次面试，我叫迟贺，就读于黑龙江工程学院，是一名大四的学生，在学习期间我对c++比较感兴趣，在校期间，除了完成学校安排的课程外，我还通过自学完成了几个项目，在项目的开发过程中，我对c++语言的了解和实际应用有了更深的理解，我能为您介绍一下我的项目吗？

# 为什么当时这些功能没有实现呢

因为我当时时间有限，功能没有实现，做版本的迭代，逐渐添加新功能，其实我还想添加文件传输，音视频等功能，说一下大概的思路（稍微提一下孜孜不倦，热爱学习，自学）

# IM项目介绍    2022年学习网络之后做的   4个月

## 1.**背景**：

小组协作交流工具，因为学校经常会有需要完成小组合作的作业，需要小组成员之间进行交流，但是市面上的一些其它通信交流软件因为会有干扰，比如各种消息，广告。因此我就想自己做一个纯净的实时交流软件，仅用于小组之间的交流。正好学校讲到了TCP通信协议，我就以此为基础，通过看书，网上看资料，自己添加了一些功能，完成了这个交流平台。

## **2.整体结构**：

因为每个同学都需要一个客户端，因此我采用了C/S架构，包括一个服务器，若干个客户端，数据库。使用Qt实现客户端的部分。vs2019完成服务端。传输协议使用的是TCP传输控制协议。我是采用分层进行实现的，最底层的是TCP连接，客户端和服务端代码代码，使用中介者模式进行解耦。服务端最上层有一个核心处理类，用来处理客户端传输的数据并根据数据操作数据库，进行增删改查。客户端最上层是核心处理类还有几个UI界面，用来处理用户操作产生的信息，以及将信息发送给服务端，界面包括注册界面，登录界面，好友信息列表界面。

## **3.基本功能**

可以实现一些基本的功能， 包括登录、注册、聊天、群聊、添加好友、发送文件、视频聊天（了解的说这个）等功能

### 3.1注册

**注册功能简介**: 注册主要是 Mysql 和 Vs 的连接，注册信息主要包括手机号，昵称和密码，当用户发送注册请求给服务器的时候，服务器主动分配id（也就是主键，逐渐增长，不能重复），服务器在收到消息的时候的时候会在数据库中查询手机号和昵称是否存在，如果存在会重新返回错误信息，如果不存在会将手机号和昵称存入数据库。

### 3.2登录

**登录功能**：

登陆时服务器会到数据库中会到数据库中进行查询手机号是否存在

如果不存在，客户端弹出“手机号不存在”

，如果存在，会判断手机号和密码是否匹配，如果不匹配，客户端弹出错误信息“密码错误”，如果匹配，则登陆成功

客户端收到登陆结果，隐藏登录界面，显示好友界面，根据登陆用户的id查询自己的信息，好友id的信息，好友关系列表(自己的信息，显示到 界面上 好友的信息，判断是 否在好友列表上，如 果在，更新信息 如果不在，new一个对 象，显示在好友列表 上),

判断好友是否在线，并发送是否在线的信息给客户端，（是否暗显）

### 3.3添加好友





### 3.4聊天功能

用户的消息发送，用户A想向用户B发消息，点击好友列表上的用户B，会弹出一个聊天框，输入框输入消息，点击发送消息按钮，客户端将消息收集起来并进行简单的判断（是否是空消息或者全是空格），然后客户端打包成结构体通过中介者类传到Inet层，发给服务端，服务端收到消息之后进行拆包，判断结构体属于那种消息，这次就是聊天请求，将其转到相应的处理函数，进行更深层次的拆包，通过B消息的id，找到对应的socket，通过对应的socket转发给B,客户端将消息显示出来，这样他们就可以进行通信。

### 各个功能的类图

![image-20240311193150498](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240311193150498.png)

![image-20240311193218573](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240311193218573.png)

![image-20240311193235264](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240311193235264.png)

![image-20240311193259365](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240311193259365.png)







![image-20240311193323071](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240311193323071.png)





## 加密

其它加密：QT自带加密

密码加密：使用的是MD5加密算法（信息摘要算法5），是一种常见的哈希算法，用于将任意长度的数据转换为固定长度的（通常是128位或16字节）哈希值。（MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。）MD5是单向函数，即无法从生成的哈希值反推出原始数据，这也是我使用它的原因。

passwd:1234     content:  1234_key=client(密钥) –》MD5  生成32为10进制数。

在数据库中保存密码时，我会明文密码进行**MD5加密**，得到一个不可逆的哈希值。 这个哈希值被存储在数据库中，作为用户身份验证的依据。 当用户尝试登录时，系统会将用户输入的密码进行MD5加密，并与数据库中存储的哈希值进行比对。结果吻合，才能成功登录。（发散：设想但没有实现 彩虹表   破解 加盐 1a2b3c4d_   参杂无用信息，能登陆，保护了一些信息

MD5 拦截  安全措施  安全验证 **手机号验证 人脸识别 ip异地非法**访问

多端登录  联动效果）

## 数据量级

## 打包到最底层数据包结构

最外层数字 里面是id socket 然后是消息



## 离线处理：好友请求 文字消息 怎么实现

客户端和服务端都要存

加载历史信息(本地)

用户 客户端存储的数据库  sqlite  文件存储类型数据库  每一个数据库就是一个文件  xx.db

服务器  离线记录（漫游信息）-->  数据库 --> 用户B 登录 推送

## TCP为什么可靠？

1）三次握手 四次挥手

2）确认·应答

3）重传

4）流量控制

5）拥塞控制

6）校验和

7）合理分段

8）重排机制，确保顺序

## 群组消息实现

### UDP实现群聊？

udp	局域网   	广播	组播 D类地址	233.233.233.233

腾讯QQ用的是可靠UDP

重传–》超时重传，需要序列号 确认号—》确认应答 发的每一个包

广域网	TCP	

发的每一个包，首先要缓存，然后这个包有一个定时器，看一下有没有确认，如果没确认就重传，没超时，关闭定时器

**UDP 丢包了，怎么处理？**

如何确认丢包：客户端收到包之后进行回复，如果没收到回复就认为他丢包了。

确认丢包了怎么办：可以广播，重复发送一个包，如果客户端收到重复的就丢弃。或者单播，根据客户端的回复进行判断那个客户端没有收到包，单独发一遍给他。

### TCP实现群聊

**为什么用TCP实现网络?**

更容易，开发更快，不会丢包，顺序不会乱，可靠

**数据库表问题**

群和用户关系的表

群信息单独写一个表

如果觉得开发查询比较繁琐，可以考虑写视图  用视图查

## 群里消息延迟怎么处理

TCP一定会有先收到后收到的问题，比如抢红包最后一个永远抢不到。

多线程：500个人使用10个线程，一组50人，同时进行，可以某种程度上解决延迟问题

延迟显示：（红包），消息先发出去，等消息都到客户端之后统一激活，这样用户肯定是同时看到了，会有一定延迟

随机：500人先后随机处理发送到顺序，总有一个人运气不好

## 传输文件怎么实现的

首先就是上传  ，将要传的文件上传到服务端，再由客户端决定是否下载

合理 推荐到 ：  发文件上传到服务器，然后转给另一个人

群文件

扩展： 

## 断点续传功能：

客户端上传时断了，发送一个请求包进行询问，服务端查询服数据库，看文件上传了多少字节，把这些信息打成一个包，返还给客户端，客户端直接跳到断的那个位置，继续之前的上传任务

总结起来就是 发送请求  问服务器在哪断了  服务器告诉你，客户端转到那个为止开始读取上传

## 迅雷的断点续传

能续传，能加载，可以把一台主机正在下载的文件可以换到另一台主机上，仍然可以进行断点续传。首先要把，下载的文件转移走，配置文件转移走，双击配置文件就可以继续下载，



## 为什么用Qt，不用其他的呢?

其实在做这个项目之前，我还了解过VS的MFC,但是技术比较陈旧，很久没有维护更新了，开发起来比较困难，时间也长，网上的资料还比较少，所以我就选择了Qt,我就没有去学。

Qt 是一个跨平台的 C++ 开发库，主要用来开发图形用户界面(GUI) 程序，当然也可以开发不带界面的命令行 (CUI)程序。同时也是图像用户界面应用程序框架，它为应用程序开发者提供建立艺术级图形界面所需的功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。 Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、Unix，智能手机系统 Android、iOS、WinPhone，嵌入式系统 ONX、VxWorks 等等。

优点：

1.面向C++的开发库，

2.跨平台：如果你的程序需要运行在多个平台下，同时又希望降低开发成本，Qt 几乎是必备的。

3.漂亮的界面：Qt 很容易做出漂亮的界面和炫酷的动画，而 MFC、WTL、wxWidgets 比较麻烦

//不太明白，不讲了 4.独立安装：Qt 程序最终会编译为本地代码，不需要其他库的支撑，而Java 要安装虚拟机，C# 要安装.NET Framework

5.网络上关于Qt的资料比较多，易于学习

## 考虑了其他的图形设计工具吗

我当时也在网络上查询了一下工作，最后因为这些优点选择了Qt,不是因为其他的软件不够好，而是我觉得Qt是最合适的，所以就没有学其他的。

NET开发平台]

HTML5/JavaScript

Visual C++

C++图形用户界面开发

## Qt信号与槽的连接有哪些方式呢？

### 添加信号与槽的方式

1.手动从窗口添加

2.组件-》右键-》转到槽-》选择一个信号-》自动生成槽

3.自定义信号和槽

```c++
自定义信号和槽机制使用方法（两个类之间) :
1、两个类都必须继承自QObject，并且有Q_OBJECT宏  在TcpClientMediator  .h文件继承QObject
2、发送数据的类（TcpClientMediator.h）在头文件中使用signals声明信号(返回值是void，不是函数，不需要实现
 3、接收数据的类(ckernel)里头文件中使用slots声明槽函数(返回值和参数与信号一样，需要实现)
4、绑定：connect
在接收数据的类里面，在发送数据的类对象new出来以后绑定
```

### connect的几种写法

```c++
一、老版本标准 connect
connect(btnClick,SIGNAL(Clicked(bool)),this,SLOT(onClicked(bool)));
二、QT5.0后推出 connect
connect(btnClick,&MyButton::sigClicked,this,&Widget::onClicked);
三、某版本QT推出 connect
很显然这种写法相对于第二种会比较简单些，但依然不能连接到重载的槽函数，如果连接重载槽函数，还是会报错误。
connect(btnClick,QOverload::of(&MyButton::sigClicked),
this,&Widget::onClicked);
```

### 信号与槽的连接模式

五种连接类型

1. 自动连接 Qt::AutoConnection （0）
	（默认）信号发射对象如果和槽的执行对象在同一个线程，那么将是直连方式，否则就是队列方式。

2. 直接连接 Qt::DirectConnection（1）
	相当于直接调用槽函数，但是当信号发出的线程和槽的对象不再一个线程的时候，则槽函数是在发出信号的线程中执行的。

3. 队列连接 Qt::QueuedConnection（2）
	信号发射后，当事件循环返回到接收线程时槽函数就执行了，也就是说这种连接方式不是立即触发槽函数的，而是要排队等的，并且是在槽函数的线程中执行。

4. 阻塞队列连接 Qt::BlockingQueuedConnection（3）
	在槽函数返回之前信号发射所在的线程都是阻塞的。即发送完信号，发送线程会阻塞，直到槽函数线程运行完毕。

5. 唯一连接 Qt::UniqueConnection（0x80）
	防止重复连接。如果当前信号和槽已经连接过了，就不再连接了，即connect连接失效，可通过按位或 | 与以上四个结合在一起使用。



### 信号和槽调用机制及安全问题

多线程参数分析
一般来说，使用到connect第五参数，都会涉及到多线程的调用。而在多线程中，发出信号和调用槽的方式分两种：同步调用 & 异步调用

同步调用：发出信号后，当前线程等待槽函数执行完毕后才继续执行。
异步调用：发出信号后，立即执行剩下逻辑，不关心槽函数啥时候执行。

信号参数安全
因为一个信号可以连接多个槽函数，如果参数是T * 或者是T &话会不会第一个槽函数改变参数的值，然后第二此调用的参数就已经不是信号发出的值

### 多线程代码实现

Qt有两种多线程的方法，其中一种是继承QThread的run函数，另外一种是把一个继承于QObject的类转移到一个Thread里。

### QApplication的作用

QApplication是Qt框架中的一个类，它是Qt应用程序的核心类之一，主要作用是初始化应用程序、管理应用程序的事件循环、处理应用程序的命令行参数、设置应用程序的属性等。在Qt中，大多数的GU应用程序都需要创建一个QApplication对象，因为它提供了很多与GU!相关的功能和特性，比如事件循环、信号槽机制、窗口管理等。除此之外，QAppication还提供了一些命令行参数的解析和处理，可以方便地实现应用程序的一些特殊功能。

## 为什么要写这个项目？

哪个软件里都有它，足够的通用

## 同学有没有使用它？



## 服务器为什么在Windows上面？

当时在写的时候，考虑的是先实现，找到的是Windows模型，在学习到更多的知识后，考虑移植到Linux上面，没有时间。

Linux?

里面有很多关于服务器下面的组件，更加方便，问题也会更少

windows server 不同版本，界面很少，更多空间留给开发

epoll

tcp 应用层协议  自定义协议  

## 数据的封装格式  结构体  你了解其他的吗?

我使用的是结构体

JSON ,可读性好，可以赋空，结构体不能为空，结构体在不同平台上对齐方式不同，解析数据\6678更安全。

优势：JSON 方便解析，读写便	-理解，更安全（空数据，结构体空数据有安全隐患），多端可以同时使用

结构体还有字节对齐问题

js: java script

ON:对象表示法   ison-c(linux)  github

**qt有json库**

```json
{
	"data":"1034",
    "name":"zhangsan",
    "age":18,
    "message":null,
    "hobby":["说"，"唱"]
}
```

## 为什么使用MySQL数据库

经过调查，数据库最好用，其他的没学

1. 索引，事务 一些好的特性都支持，

2. 然后开源 免费的  

3. 学习资料很多 

4. 性能好，并发强

## MySQL  哪些表？

用户信息表

用户id 手机号tel 密码passwd   age   email address remark

好友关系表

id1  id2

aid   bid

bid   aid

单向 ：关注 

## MySQL可以进行哪些优化：

### 表结构设计优化

1. 增加中间表，对于需要经常联合查询的表，可以建立中间表以提高查询效率
2. 优化数据类型，更小的通常更好（占用更少的磁盘），简单就好（更少的CPU周期），尽量避免null,
3. 表设计不能有太多的列，数千的列会影响性能
4. 关联操作设计的表不要太多，否则执行会很慢
5. 遵循数据库的范式要求，尤其是前三个范式

### 索引优化

索引应该是对查询性能优化最有效的手段了，它能够轻易地将查询效率提高几个数量级

**索引的缺点**

虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件

建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快

### SQL语句查询优化

1. 避免 SELECT *，只查询需要的字段

2. 索引：可以快速定位，B+树

3. 视图

4. 小表驱动大表，即小的数据集驱动大的数据集

	当B表的数据集比A表小时，用in优化 exist两表执行顺序是先查B表再查A表查询语句：SELECT * FROM A WHERE id in (SELECT id FROM B) ;

	当A表的数据集比B表小时，用exist优化in ，两表执行顺序是先查A表，再查B表，查询语句：SELECT * FROM A WHERE EXISTS (SELECT id FROM B WHERE [A.id](https://link.zhihu.com/?target=http%3A//a.id/) = [B.ID](https://link.zhihu.com/?target=http%3A//b.id/)) ;

3. 尽量使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表
4. or 查询改写成 union 查询
5. 查询语句尽可能简单，大语句拆小语句，减少锁时间
6. 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些

# 飞机大战     2021  学习完C++做的  ，学习完C++之后，想巩固一下自己的知识，右了解到Easy-X库， 边做边学，刚开始完成花了一个月，后续增加了关卡，完成之后对C++的理解加深了，

空域征战是一款经典射击游戏。玩家通过操控飞机躲避敌人的攻击并发射子弹来击败敌人，获取分数，游戏将分数实时显示在界面上，玩家可以不断挑战高分，体验紧张刺激的射击乐趣。

类似与飞机大战的游戏，首先有

背景类：背景图片加载，图片滚动

飞机类：自己的飞机，可以发射子弹，一碰就死，游戏结束

敌人的飞机：有不同的种类，不同的攻击方式，不同的轨迹，敌人飞机有血量，爆炸之后根据不同的种类可以加得分，根据得分的增加，可以解锁更多的敌人飞机种类，敌人飞机的出现方式也会有不同

子弹类

Easy-X库   加载图片，渲染方式，

输入，碰撞检测5ms，爆炸，画面更新：重绘，对应库函数，每次行动刷新一次，背景移动100ms,游戏内的行为操作10ms左右，

子弹：采用链表的结构，3点一线的方式，因为是二维坐标系，一个点就可以确定子弹的位置，敌人飞机是有体积的，也是有三个点确定的，如果子弹进入了这三个点范围内，就判定打到了敌人飞机

自己的飞机也有面积，二维平面上是否重叠

敌人飞机随机生成，刚开始的时候是固定速度移动，随着分数的增加，关卡的增加，敌人飞机的移动速度会变快，还会产生左右的随机移动。几个逻辑

当时为什么用一下知名的游戏引擎：巩固自己学到的知识，而且更有成就感，引擎后续会多了解，目前想学到更多的东西。

当时有没有比较难解决的问题：

1.敌人飞机血量归零之后，有一个爆炸效果，敌人飞机是由链表进行连接的，正常敌人飞机有一个正常的链表，爆炸的有一个爆炸的链表，使用双循环写的，但是逻辑就会进行混乱，花费了挺长时间

为什么要用链表？

链表只保存节点，如果敌人飞机爆炸的话，肯定会将爆炸的这个飞机的节点删除，而且敌人飞机也是会不断生成，增加的。

链表任意位置插入和删除的效率都是O(1),vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。
list适合有大量的插入和删除操作，并且不关心随机访问的场景

所以经过比较和思考之后，我觉得List是比较合适的。

# 如果你想学习一门新的技术，你会怎么去做？

首先我会想了解一下这门技术使用的的语言，

其次我会去看这么技术的帮助文档基本的了解，我还会去一下博客平台，

代码网站GitHub去看一下根据这门技术开发的开源项目，在看代码的实现具体是怎么样的，自己尝试做一些简单的项目，加深了解。

最后还有一些难题请教一些大佬或者同事。



# List和Vector区别

一、底层结构
 vector的底层结构是动态顺序表，在内存中是一段连续的空间。
 list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。

二、支持随机访问
 vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。
 list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。

三、插入和删除的区别
 vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。
 list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。

四、空间利用率
 vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空寂爱你利用率高，缓存利用率高。
 list的底层节点动态开辟空间，小姐点容易造成内存碎片，空间利用率低，缓存利用率低。

五、迭代器和失效问题
  vector的迭代器是原生态指针。
  list对原生态指针（节点的指针）进行了封装。
迭代器失效问题：
  vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。
  list在插入元素的时候不会导致迭代器实现，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。

六、使用场景
  vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。
  list适合有大量的插入和删除操作，并且不关心随机访问的场景



# i++与++i的区别

++i在表达式执行时进行，而i++在表达式结束后进行加操作

临时对象：

​	对应内置数据，两者没有区别；

​	对应自定义类型，i++会产生临时对象，因此效率不如++i

++i没有参数，i++有参数

```c++
//类代码
#include<iostream>
using namespace std;
class Myclass
{
    public:
    Myclass(int val=0:a(val)){}
public:
    //前置
    MyClass &operator++(){
        ++a;
        return *this;
    }
    //后置
    MyClass operator++(int )
    {
        MyClass temp=*this;
        ++*this;
        return temp;
	}
}
```

# UDP可靠传输

## 一、TCP 是如何提供可靠传输 

1. 建立连接（标志位）：通信前确认通信实体存在。 
2. 序号机制（序号、确认号）：确保了数据是按序、完整到达。 
3. 数据校验（校验和）：CRC 校验全部数据。
4. 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。 
5. 窗口机制（窗口）：提供流量控制，避免过量发送。 
6. 拥塞控制：同上

## 二、TCP 不用于网络游戏的原因 

​		1. 首先，TCP 是一个流式协议，所以你只需写数据到一个流，TCP 会确保它们到达另 一方。因为 IP 协议是建立在数据包上的，而 TCP 协议又是建立在 IP 协议上的，因此 TCP 必需将你的流式数据拆分成数据包。所以，一些内部的 TCP 代码将你发送的数据放入消息 队列，当队列中有足够的数据，它才会发包给另一个机器。这就会有一个问题，如果你发送 一个很小的数据包。**TCP 可能会决定它不会立即发送数据，直到缓冲区有足够的数据组成一 个合理大小的包。这样客户端的体验就会很差**。

​		TCP 有个选项，你可以用来修复它的这种行为叫作“TCP_NODELAY”。这个选项通知 TCP 不用等到队列中有足够的数据，立即发送你写入的任何数据。

[TCP连接中启用和禁用TCP_NODELAY有什么影响？-CSDN博客](https://blog.csdn.net/lclwjl/article/details/80154565)

2. 更关键的是 T**CP 可靠性在于重发和重组。当一个数据包丢失后，就不得不停下来， 等待这个数据包重传。即使最近的数据达了，新的数据已经到达队列了，你还是不能读取它， 直到你收到了丢掉的数据包。**

## ==三、如何用 UDP 实现可靠传输== 

UDP 的可靠传输实现分为两部分“可靠性”和“避免拥堵”。 

1、可靠性：采用重发机制。 

（1）、类似 TCP 的 ack 机制。关于丢包检查，可以采用一个近似 TCP 的 ack 机制，可 以给每个数据包都添加一个 sequence ID，然后发送端就依次发送数据包，接收端收到数据 包后就可以根据 sequence ID 来判断是否有丢包了。接收端需要发该 sequenceID 的 ack 给 发送端，发送端才会知道这个包是否已经送达。与 TCP 不同的是如果数据包 n 丢失了我们 也从不暂停重新发送它，而是把它留给应用程序来编写一个包含丢失数据的新的数据包，必 要的话，这个包还会用一个新的序列号发送。ack 本身也有可能丢包。 

（2）、可以这样，发送一个 sequence ID 的 ack 时，附加一个 32bit 的位序列，表示当 前 sequence ID 之前的 32 个连续顺位的数据包是否已经送达。其实就是冗余的发送连续 32 个包的送达状态，如果 bit 为 0 说明这个包还没到，如果为 1，说明已经收到了。这样一来， 除非连续丢包 30 多次，ack 是一定会送到的，这种几率已经非常小了。 

（3）、相应的，在发送端设置一个超时机制，这个时间差不多比连续发 30 个 ack 的时 间长一点，如果发送一个包后开始计时，达到超时还没有收到 ack，这个包就丢失了。 

（4）、最后发现了丢包也不一定需要重发。是否重发可以和游戏逻辑结合起来。因为游 戏战斗的同步速率很高，丢一个没有很大影响。

2、避免拥堵 

（1）、衡量往返时间(RTT):对我们发送的每个数据包，我们对数据包队列中包含的序列 号和他们发送的时间添加一个登记。 当我们收到一个应答时，我们找到这个登记并记录本

（2）、通过往返时间来调整数据包的个数。当网络条件好的时候我们每秒发送 30 个数 据包，当网络条件差的时候我们降至每秒 10 个数据包。

# assert

assert宏的原型定义在  中，其作用是如果它的条件返 回错误，那么它先向stderr打印一条出错信息，然后通过调用abort来 终止程序运行。其只有在debug版本的时候生效，而release版本将失 效，因此不要将改变环境的语句放入其中：

# 模拟面试一

# 引用与指针有何区别？何时只能使用指针不能使用引用？

1.如果一个指针所指向的对象，需要用分支语句加以确定，或者在中途需要改变他所指的对象，那么在它初始化之后需要为他赋值，而引用只能在初始化时指定被引用的对象，所以不能胜任。

2.有时一个指针的值可能是空指针，例如当把指针作为函数的参数类型或返回类型是，有时会用空指针表达特定的含义，而没用空引用之说。

3.使用函数指针，由于没有函数引用，所以函数指针无法被引用替代。

4.使用new创建的对象或数组，需要用指针来存储它的地址。

5.以数组形式传递大批量数据时，需要用指针类型接受参数。

# 面向对象思想讲解一下？

# 父类子类构造析构执行顺序

# 讲解STL容器

# map和hash_map区别？

 1、构造函数 hash_map需要hash函数，等于函数；map只需要比较函数（小于函数）。
 2、存储结构 hash_map采用hash表存储，map一般采用红黑树实现。因此内存数据结构是不一样的。
 3、STL的map底层是用红黑树实现的，查找时间复杂度是log(n)；
 4、STL的hash_map底层是用hash表存储的，查询时间复杂度是O(1)；
【2】什么时候用map，什么时候用hash_map？

总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;
而map的查找速度是log(n)级别。并不一定常数就比log(n)小， hash还有hash函数的耗时，明白了吧
，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别
严格，希望 程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你
的hash_map对象特别多时，你就更无法控制了，而且 hash_map的构造速度较慢。
现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用
【3】Hashmap产生冲突如何处理，如何优化？

STL 中 HashMap 解决冲突一般采用链表法，其特点是利用空间换时间，查找复
杂度能达到常数级别。通常还有一种解决冲突的办法，开放地址法，分别有线性
探测（Linear probing）、二次探测（Quadratic probing）、二次哈希（Double 
hashing）三种方式。

# List和Vector区别？

一、底层结构
 vector的底层结构是动态顺序表，在内存中是一段连续的空间。
 list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。

二、支持随机访问
 vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。
 list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。

三、插入和删除的区别
 vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。
 list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。

四、空间利用率
 vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空寂爱你利用率高，缓存利用率高。
 list的底层节点动态开辟空间，小姐点容易造成内存碎片，空间利用率低，缓存利用率低。

五、迭代器和失效问题
  vector的迭代器是原生态指针。
  list对原生态指针（节点的指针）进行了封装。
迭代器失效问题：
  vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。
  list在插入元素的时候不会导致迭代器实现，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。

六、使用场景
  vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。
  list适合有大量的插入和删除操作，并且不关心随机访问的场景



# 为什么用Easy-x库？你使用之后对它的评价是什么？

EasyX 是针对 C++ 的图形库，可以帮助 C++语言初学者快速上手图形和游戏编程。 **安装简单（极其简单），使用简单（这个必须赞），唯一一点不好的，就是只能支持VS系列产品（VC6.0，VSxxx，不包括VSCode）**

# 服务器在Windows下有什么缺点？

# 同步阻塞多线程有什么优点？

# 应用层自定义协议？

# 数据库有哪些表？

# 用户信息表为什么要有主键呢？它的好处是什么？

# 介绍一下事务？具体操作是什么？

 作为单个逻辑单元执行的一系列sql操作 要么都执行要么都不执行 

特性:ACID 

A 原子性:事务是最小的工作单元，不可再分，要么都执行，要么都不执行 

C一致性:数据库的完整性约束不能被破坏。 

I隔离性:并行执行的事务之间是隔离的，相互不影响。 

D 持久性：之后数据改变永久保存 

语法:transaction 

开启事务：start transaction; #执行语句； 

... 

提交:commit; 

回滚：rollback； 

# TCP为什么可靠？

1.三次握手和四次挥手

 2.重传和确认的机制 

3.合理的分段 

4.校验重新排序 

5.滑动窗口—流量控制：流量控制通过滑动窗口的方式实现，如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 

6.拥塞窗口—4种拥塞控制算法：在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销。

# TCP有什么问题？（粘包）



# C++实现单例模式构造？



# 数组循环顺序打印

# 二进制1的个数

# 模拟面试2

## 可以发图片吗

写入本地文件了

## 同步阻塞多线程

## 支持单聊功能，怎么区分？

## 做标识为什么不是socket?

## 网络发送请求时，发送函数，发送一个长度，返回一个长度，都是什么意义呢

关于send函数的阻塞和非阻塞

## 协议包大小？？？没太明白

## 大概介绍智能指针？

大概四种

unique_ptr 如何释放？

## 类向下转换，动态转换？

## C++单例模式？

## Easy-X库？

不支持多个窗口同时传输，多个类切换不同的方法

## 消息函数为什么map做映射？

可拓展性，接口

## 人类识别opencv?

32还是64

版本？

## IM技术亮点？

## Qt信号和槽的机制？

中介者，一对一，一对多。

实现机制

connect绑定方法？（第五个参数）

## windows服务器缺点？

连接客户端数量不够

为什么每一个客户端都要都要新建一个线程。

recvfrom:怎么设置非阻塞

非阻塞没接收就休眠一会，休眠完了再接收？（不能第一时间使用）

## 局域网变成广域网？

1.服务器

2.IP

## 数据库存储了哪些信息？

用户信息

好友信息表(两列 idA,idB访问一个id，双向存储，便于查询)

聊天内容缓存 (源id,目的id，内容，图片，表情包在数据库中的id)

## 使用什么手段进行验证？

socket

冒充：登录匹配 

​			ip属地存储，进行内存判断

## C++11特性  为什么是C++11特性？

## 了解比较深入 ，时间

## 动态数组在扩容的时候涉及到拷贝吗？



## 哈希冲突怎么解决？在项目中遇到过吗？

了解过哪些哈希？

哈希真的能达到O(1)吗？

## 子类继承了父类，不能实例化对象？

## Qt随便说两个函数

## Windows服务器，网关的作用？解决了什么问题？

## 缓存了什么东西？缓存到了哪里？一共有几张表？

## 历史聊天记录怎么保存？

定义好了文件保存路径

## 客户端历史聊天记录内容不存在了，以什么形式做保存，为什么不保存？

## 飞机大战怎么判断炮弹和飞机进行碰撞？

## 整个架构设计？

游戏块

关卡模式

boss类

玩家飞机类

炮弹管理类

积分榜类（战绩）

纯虚类有哪些

## 父类函数定义了哪些动作？

移动，发送炮弹，接口

## 飞机和炮弹之间的关系



## 社会责任？

## 无序数组，中位数？

排序，

## 无向无权连通图，最短路径



## 二进制最右侧非零二进制位？



无用的话不用太多，给面试官时间，直接一点。不要有攻击性。

不用把面试官放到对立面，直面问题。扩展的知识面不太多，架构不要避重就轻，底层的技术细节不清晰，实战代码实现不是太好。

有些地方咬的太死了，问题不要太死，

# 模拟面试3

## 封装为什么是类而不是结构体

## C++结构体和类的区别

## 继承和组合对象大小做对比，大小有什么差异？

## 类成员访问两个成员，效率不同，（继承与组合也包括进来）

## 虚函数和普通函数区别？

## 左值引用和右值引用在哪些情况下使用呢？

## 单例模式

## 队列和双端队列区别是什么，适用于具体区别是什么？

## QT操作信号的函数

## MySQL基本操作最多建立几张表？

## 左联，内联，右联的区别是什么？

## 线程间通信？

## 只能用于线程间通信，不能用于进程间通信

有序数组，数字出现次数超过长度一般，找出数字，

全排列，去重



# 锐我科技

北京锐我科技  c++开发工程师  30分钟
没让自我介绍，没让介绍项目 直接问问题

1、讲一下完美转发（右值引用里面的）

2、了解lambda表达式吗

3、智能指针用来解决什么问题

4、设计模式桥接模式了解吗（不了解  说了解工厂·，单例，中介者

5、工厂模式和抽象工厂区别，如何使用

6、讲一下工厂模式

7、数据库引擎有哪些

8、索引底层数据结构，b树b+树区别

9、二分查找（分治法

10、了解STL吗，都有哪些·？

11、了解set吗
12、了解map和unordered_map吗

13、讲一下哈希表

14、删除一个文件中的名字，如何删除，具体过程

15、游戏3亿的用户，如何找到top前100

16、游戏视野机制，如何确定视野范围

17、你觉得你前面回答的怎么样

反问:

## 游戏大区前多少名，使用什么排序算法？  堆排序

快速排序、归并排序、堆排序

## 快速排序

核心思想：找到一个标准值，比标准值小的放在左边，比标准值大的在右边，标准值的左右两侧就没有必要进行比较了，对左右两部分重复之前的操作。

实现方法：

**挖坑填补法：**

1. 先选择一个标准值（一般为首元素），
2. 变量：定义两个变量，一个指向首，一个指向尾。

（1）从右向左找比标准值小的放入左侧坑里 

（2）从左向右找比标准值大的放右侧坑里 循环直到两个变量相遇 

   3. （1）放入标准值（位置即为两个变量的相遇位置） 

	（2）根据标准值的位置分为两部分重复1、2、3的操作（递归)  **无法分割结束**

分割：开始位置，标准值的前一个位置

​			标准值的下一个位置，结束位置

**有几个优化：**

**区间分割法**

只找比标准值小的，把它放在前面，那么是不是自然只剩下大的在标准值后面了。

我们需要两个变量，一个是小区间变量（首元素的前一个），一个是遍历变量（首元素），选取最后的元素为标准值，

比标准值小，和小区间变量下一个元素进行交换

比标准值大，处理下一个元素，遍历元素往下走

**标准值的选取**

1. 3选1 头，尾，中间这三个数的中间值。选取为中间值 

2. 9选1(3个一组，选三组，最后去一个平均值)



4、当快排的数据量分割到一定小时（<16)，我们此时可以选择用**插入排序 (核心思想（无交换）：将待排序数据分成两部分，一部分有序，一部分无序，将无序元素依次插入到有序中去，完成排序。 )**

5.以循环加额外申请空间来取代递归（避免系统异常）

## 归并排序（MergeSort)

将多个有序数组合并成一个

步骤：

1、拆分：左半部分：起点到中点，处理成有序，

右半部分：中点下一个到结尾，处理成有序。

 2、都有序后，进行合并。

## 堆排序

[堆排序详细图解（通俗易懂）-CSDN博客](https://blog.csdn.net/weixin_51609435/article/details/122982075)

堆：大顶堆（大根堆）大堆，小顶堆（小根堆）小堆。

逻辑结构是完全二叉树，本质是数组，

```c
有n个数据，每个节点0~n-1，左：2*i + 1，右：2*i + 2，父亲节点：0~n/2-1。
```

大堆：父亲与孩子之间，父亲是最大值。 小堆：父亲与孩子之间，父亲是最小值。 所有节点都满足。

步骤： 1、建立初始堆（调整成大堆和小堆），从下向上调（即从n/2-1的位置开始） 2、排序 （1）堆顶与当前的数组末尾交换 （2）调整堆顶

![image-20240312122029260](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240312122029260.png)

最后一层第一个非叶子节点的索引就是arr.len/2-1,最后一个非叶子节点5/2-1=1（数组下标）  即为6

比较它的左右节点中最大的一个值，是否比他大，如果大就交换

堆排序是不稳定的排序，空间复杂度为O（1），平均时间复杂度为O(nlogn),最坏情况也稳定在O(nlogn)

## 游戏内有地图，视野机制，怎么区分有那些怪，怎么设计，地图怎么切分？

游戏中的地图设计、视野机制、怪物区分以及地图切分等问题，涉及到的是游戏设计和计算机图形学的一些基本概念。以下是一些基本的设计和实现方法：

1. [**地图设计**：地图通常会被划分为一系列的网格或者节点，这些网格或节点可以用来表示游戏中的地形、障碍物、道路等元素。在一些开放世界游戏中，地图可能会被划分为更大的区块，每个区块包含了一定范围内的所有元素]
2. [**视野机制**：视野机制通常通过一种叫做“阴影投射”的技术来实现，这种技术可以计算出玩家或者怪物能够看到的区域]([。在一些游戏中，还可能会使用一种叫做“光线投射”的技术，这种技术会从玩家位置向外发射一系列的光线，当光线碰到障碍物时就会停止，从而计算出玩家的视野](
3. **怪物区分**：怪物的区分通常是通过给每种怪物分配一个唯一的标识符来实现的，这个标识符可以是一个数字、一个字符串，或者是一个更复杂的数据结构。在游戏运行时，可以通过这个标识符来查询和操作怪物的属性和状态。
4. [**地图切分**：地图切分是一种优化技术，它可以将大型的地图切分成一系列的小块，每个小块都包含了一定范围内的所有元素。通过这种方式，游戏只需要处理玩家当前所在的那一块地图，而不是整个大地图，从而大大提高了游戏的运行效率](
5. [**算法实现**：以上提到的这些功能，都需要通过算法来实现。例如，视野机制的实现可能会需要用到图形学中的光线投射或者阴影投射算法]([；地图切分的实现可能会需要用到空间划分或者四叉树等数据结构](。具体的算法实现会根据游戏的需求和性能要求来选择。

以上只是一些基本的设计和实现方法，具体的游戏可能会有更复杂和专门的设计。希望这些信息对你有所帮助！

设计游戏内地图、视野机制以及怪物区分的方案涉及多个方面，包括地图切分、视野算法和怪物设计。下面是一个简单的概述：

### 地图切分

1. **网格划分：** 将地图划分为一个个网格单元，每个单元可以表示一个房间、区域或特定大小的空间。这有助于进行更有效的碰撞检测和管理游戏世界。
2. **四叉树：** 使用四叉树数据结构可以动态地划分地图。这使得只有在玩家靠近某个区域时才需要加载和渲染该区域，提高了效率。

### 视野机制

1. **射线投射：** 从玩家位置向周围发射射线，检测射线与地图的碰撞。射线能够决定玩家能够看到的区域，形成视野。
2. **遮挡剔除：** 考虑到遮挡关系，通过检测视线上的遮挡物体，可以提高游戏的真实感。一些算法，如光栅化算法，可以用于检测可见性。
3. **视锥体：** 使用视锥体来表示玩家的视野范围。在视锥体内的区域被认为是可见的，而在视锥体外的区域则不可见。

### 怪物区分

1. **怪物属性：** 为每个怪物定义一些基本属性，如类型、等级、生命值等。这有助于在游戏中对怪物进行区分。
2. **AI行为：** 不同类型的怪物可以有不同的行为模式和策略。一些怪物可能更善于追击，而另一些可能更倾向于躲避玩家。
3. **图形/外观：** 怪物的外观和图形也是区分它们的重要因素。不同类型的怪物可以有不同的外观，使其在游戏中更易识别。

### 算法实现

1. **A\*路径规划算法：** 用于怪物追击玩家或在地图上移动，确保它们能够找到最优路径。
2. **碰撞检测：** 用于检测玩家与地图、怪物之间的碰撞，以及怪物与其他对象（如子弹）之间的碰撞。
3. **光照和阴影算法：** 提高游戏画面质量，使得玩家在视野内看到的怪物更加逼真。

以上只是一个简要的概述，具体的实现会根据游戏的需求和设计目标而有所不同。游戏开发中可能需要结合具体的游戏引擎和编程语言来实现这些功能。

## 怎样判断游戏下线后，装备是否被修改过?

当一款游戏下线后，要统计装备是否被修改过可能会比较复杂，因为游戏服务器通常会在运行时对游戏数据进行处理，而一旦下线，游戏服务器通常就无法直接访问了。然而，下面是一些可能的思路，尽管并不是万无一失的方法：

1. **数据备份比对：** 如果在游戏服务器下线之前有数据备份，可以通过比对备份前后的数据来检测装备是否被修改。这可能需要对备份的数据进行分析，找出装备相关的信息。
2. **日志分析：** 游戏服务器通常会记录日志，包括玩家的行为和操作。通过分析游戏日志，特别是与装备相关的日志，可以尝试检测是否有异常操作。
3. **数据快照：** 在游戏下线前，可以对玩家数据进行快照，包括装备信息。在下线后，通过比对快照和下线时的数据来检测是否有不一致之处。
4. **反作弊技术：** 游戏通常会使用一些反作弊技术，例如加密通信、防修改的数据存储等。在游戏下线后，可以通过分析这些技术的实现来检测是否有装备被修改的痕迹。

游戏装备是否被修改过的统计，通常需要依赖游戏的后台数据和日志系统。以下是一些可能的方法：

1. [**数据追踪**：在游戏运行期间，可以通过在后台数据库中记录每次装备属性变化的日志，来追踪装备的修改历史。这种方法需要在游戏设计初期就考虑到数据追踪的需求，并在游戏代码中添加相应的数据记录和查询功能](
2. [**数据校验**：可以通过数据校验的方式来检测装备数据是否被非法修改。例如，可以在游戏服务器上定期对玩家的装备数据进行校验，如果发现数据异常（如装备属性超出正常范围），则可能是装备数据被修改][
3. **异常行为检测**：在一些情况下，装备被修改可能会导致玩家的游戏行为出现异常。例如，如果一个玩家的战斗力远超过正常范围，或者在短时间内获得大量的游戏资源，那么可能是他的装备被修改了。这种情况下，可以通过分析玩家的游戏行为数据来检测装备是否被修改
4. [**玩家举报**：在一些游戏中，也可以通过玩家举报的方式来检测装备是否被修改。如果有多个玩家举报某个玩家的装备异常，那么游戏运营商可以对该玩家的装备数据进行审核]

### STL:

# C++11特性

## 一、auto：自动类型判断

auto是通过初始化表达式进行类型推导，假设没有初始化表达式，就无法确认a的类型

## 二，增强的范围for

```c++
list<int> lst3{ 2,3,4 };
	for (int v : lst3) {
		cout << v << " ";// 2 3 4
	}
	cout << endl;
```

## 三、nullptr：

在 C 语言中用的 NULL 其实是 0 的宏，而 nullptr 就是空，空是空，0 是 0， 空和 0 不一样；

## 四、左值引用与右值引用的区别？右值引用的意义？

左值引用是对左值的引用，右值是对右值的引用。

（1 const 左值引用能指向右值：局限不能修改这个值

2 **右值引用通过std：move(v）可以指向左值**，这时右值是将亡值

**3 声明出来的左值引用或者右值引用都是左值**）

功能差异：

左值引用避免对象拷贝，例如函数传参，函数返回值

右值引用：实现**移动语义**  实现**完美转发**

实现**移动语义**：

1. 对象赋值时，避免资源的重新分配。  
2. 移动构造以及移动拷贝构造。
3. STL应用：没有使用深拷贝，而是移动语义，堆上的资源没有重新分配，效率非常高

![image-20240313110458328](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240313110458328.png)

4. std::unique_ptr
5. std::move(v)

**完美转发**：函数模板可以将自己的参数完美的转发给内部调用的其他函数。不仅能转发参数的值，还能保正被转发的左右值不变。

![image-20240313111534378](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240313111534378.png)

借助万能引用解决通过引用的方式接收左右属性的值。

引用折叠规则，参数为左值或左值引用，T&& 将转换为int&

​							参数为右值或右值引用，T&& 将转换为int&&

std::forward<T>(v)  解引用 ：T为左值引用，V要转换为T类型的左值，T为右值引用，V要转换为T类型的右值

左值：**可以**在等号左边，能够取地址，有名字。

举例：

- 变量名
- 返回左值引用的函数调用
- 前置自增（++i就是左值），前置自减
- 赋值运算或者复合赋值运算：(i=9)=100;(i+=10)=100;
- 解引用

右值：只能在等号右边，不能取地址，没有名字。



纯右值：

- 字面值
- 返回非引用类型的函数调用。
- 后置自增/自减
- 算术表达式
- 逻辑表达式
- 比较表达式

将亡值：c++11新引用的与右值引用（移动语义）相关的值类型

将亡值用来触发移动构造或移动赋值构造，并进行资源转移，之后就会灭亡

## 智能指针种类以及使用场景

**指针管理的困境？**

资源释放了，指针没有置空(野指针，指针悬挂：有多个指针指向同一个内容其中一个指针删除了并且浮空了，踩内存)

没有释放资源，产生内存泄漏（忘记delete，

重复释放资源，引发cordump

**怎么解决的？**    RAII

**智能指针的种类？**

**shared_ptr**

```c++
#include<memory>
using namespace std;
int main()
{
    //初始化方式一,make_share效率高
    shared_ptr<int> p;
	p=make_shared<int> 100;
    //初始化方式二
    shared_ptr<int> p1{new int(100)};
    
    shared_ptr<int> p2=p;
    cout<<*p<<endl;
    
    *p2=321;
    cout<<*p<<endl;
}

```

```c++
#include<iostream>
#include<memory>
using namespace std;
class Ball {
public:
	Ball() {
		cout << "ball appears" << endl;
	}
	~Ball() {
		cout << "ball disapperas" << endl;
	}
	void Bounce() {
		cout << "ball jumps" << endl;
	}
};
int main()
{
	shared_ptr<Ball> p = make_shared<Ball>();//ball appears
	cout << p.use_count() << endl;//1
	shared_ptr<Ball> p2 = p;
	cout << p.use_count() << " " << p2.use_count() << endl;//2 2
	shared_ptr<Ball> p3 = p;
	cout << p.use_count() << " " << p2.use_count() <<
		" " << p3.use_count() << endl;//3 3 3
	p.reset();//重置
	p2.reset();
	p3.reset();
	//ball disapperas

}
```

引用计数，数一数有多少个共享指针指向某个物体。会有额外的性能开销。在一些性能要求苛刻的时候不要使用shared_ptr;

Ball* rp=p.get();  使用get方法获得裸指针，

shared_ptr不要和裸指针混用

p.reset();//释放指向的kong

避免循环引用。 多线程环境注意线程安全。

**unique_ptr:**独享指针，既可以主动管理内存空间，又没有额外的性能开销。unique_ptr独享某个资源，当unique_ptr销毁或者reset的时候，绑定的资源会自动释放。不能有两个unique指向同一个资源，也就不支持复制操作。

```c++
#include<memory>
unique_ptr<int> UP=make_unique<int>(100);
```

weak_ptr 弱引用计数的共享使用权的智能指针。 weak_ptr 指向同一空间，引用计数不会加1。它的 提出主要是解决 shared_ptr 存在循环引用的问题。不能独立存在

避免悬空指针，使用 weak_ptr 之前，必须确保其所指向的对象仍然存在。 std::weak_ptr 应该通过 shared_ptr 构造而来，不可直接从裸露指针构造。 注意失效，当最后一个 shared_ptr 所引用的对象被释放时， weak_ptr 会自动失效。 多线程环境注意线程安全。注意：多线程环境下，引用计算是安全的，但是空间是不安全的。

# new与malloc 的区别：

1、new和delete是关键字，而malloc和free是函数  [下载APP](https://app.bilibili.com/)

2、new申请空间不需要指定大小，返回的是申请类型的地址。而malloc需要显式指定申请空间的大小，且返回的是void*，需要强转成需要的类型

3、new申请空间的同时可以设置初始化，而malloc需要手动赋值

4（最重要的）new 对象，自动调用构造函数，delete 自动调用析构函数， malloc 申请对象空间，不会调用构造函数，free 不会调用析构函数

# STL

## map，multimap,undered_map区别

|        映射        | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| :----------------: | :------: | :------: | ---------------- | :----------: | :------: | -------- |
|      std::map      |  红黑树  | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
|   std::multimap    |  红黑树  | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map |  哈希表  | key无序  | key不可重复      | key不可修改  |   O(1)   | O(1)     |

### STL之stack

#### 1.**什么是stack？**

1. stack是一种容器适配器，专门用在具有后进先出(LIFO)操作的上下文环境中，其删除只能从容器的一端进行元素的插入与提取操作。
2. stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。
3. stack的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下 操作： empty：判空操作 back：获取尾部元素操作 push_back：尾部插入元素操作 pop_back：尾部删除元素操作
4. 标准容器==vector、deque、list==均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。

![image-20240312165555710](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240312165555710.png)

#### 2. stack的使用

| 函数接口    | 接口说明                |
| ----------- | ----------------------- |
| **stack()** | 构造空栈                |
| **empty()** | 检测栈是否为空          |
| **top()**   | 返回栈顶元素的引用      |
| **size()**  | 返回栈中元素个数        |
| **push()**  | 将元素val压入stack中    |
| **pop()**   | 将stack中尾部的元素弹出 |

```c++
#include <iostream>
#include <stack>
using namespace std;

void test_stack()
{
	stack<int> st;
	st.push(1); // 压栈
	st.push(2);
	st.push(3);
	st.push(4);
	st.emplace(5); // C++11
	cout << st.size() << endl;
	// 没有迭代器
	while (!st.empty())
	{
		cout << st.top() << " ";
		st.pop();  // 出栈
	}
	cout << endl;
}

int main()
{
	test_stack();
	return 0;
}
```

##### 3. stack没有迭代器

> stack的所有元素进出都必须符合“先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供随机访问功能，也不提供迭代器。

#### 4.stack的模拟实现

> 从栈的接口中可以看出，栈实际是一种特殊的vector，因此使用vector完全可以模拟实现stack

```c++
#include<vector>
namespace St
{
	template<class T>
	class stack
	{
	public:
		stack() {} // 自定义类型自动调用构造与析构
		void push(const T& x) {_c.push_back(x);}
		void pop() {_c.pop_back();}
		T& top() {return _c.back();}
		const T& top()const {return _c.back();}
		size_t size()const {return _c.size();}
		bool empty()const {return _c.empty();}
	private:
			std::vector<T> _c;
```

#### STL之queue及其底层实现

1. 什么是queue？

1. > 队列是一种容器适配器，专门用于在**FIFO上下文(先进先出)**中操作，其中从容器一端插入元素，另一端提取元素。

2. > 队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列。

3. > 底层容器可以是标准容器类模板之一，也可以是其他专门设计的容器类。该底层容器应至少支持以下操作:empty：检测队列是否为空；size：返回队列中有效元素的个数；front：返回队头元素的引用；back：返回队尾元素的引用push_back：在队列尾部入队列；pop_front：在队列头部出队列

4. > 标准容器类==**deque和list**==满足了这些要求。默认情况下，如果没有为queue实例化指定容器类，则使用标准容器deque。

![image-20240312171028186](https://cdn.jsdelivr.net/gh/Chihe-Q/Pictures@master/image-20240312171028186.png)

2. queue的使用

| 函数声明    | 接口说明                                  |
| ----------- | ----------------------------------------- |
| **queue()** | 构造空队列                                |
| **empty()** | 检测队列是否为空，是返回true，否返回false |
| **size()**  | 返回队列中有效元素的个数                  |
| **front()** | 返回队头元素的引用                        |
| **back()**  | 返回队尾元素的引用                        |
| **push()**  | 在队尾将元素val入队列                     |
| **pop()**   | 将队头元素出队列                          |

3. 代码示例：

```c++
#include <iostream>
#include <queue>
using namespace std;

void test_queue()
{
	queue<int> q;
	q.push(1);
	q.push(2);
	q.push(3);
	q.push(4);
	q.emplace(5);

	cout << q.size() << endl;
	// queue没有迭代器
	while (!q.empty())
	{
		cout << q.front() << " ";
		q.pop();
	}
	cout << endl;
}

int main()
{
	test_queue();
	return 0;
}

```

3.queue没有迭代器

> queue所有元素的进出都必须符合先进先出的条件，只有queue的顶端元素，才有机会被外界取用，queue不提供遍历功能，也不提供迭代器。

4.queue的模拟实现

> 由于queue的接口中存在头删和尾插，因此使用vector来封装效率比较低，故可以借助list来模拟实现queue。



# OSI七层协议模型 层次划分及其功能

1.应用层：主要作用就是定义了应用相互交互的协议格式， 主要的协议有HTTP，HTTPS主要用于WEB服务器与浏览器的交互； SMTP，IMAP4和POP3主要用于邮件客户端与服务器的交互，DNS就 是DNS客户端和服务器的交互，提供了解析主机名到IP地址的服 务；Telnet主要用于远程登录（登陆过邮箱）；FTP用于远程文件 传输； 

2表示层：主要作用就是数据的编码解码，加密解密以及压 缩和解压这些； 

3.会话层：建立，释放以及维护连接； 

4.传输层：传输层的主要作用就是区分上层应用，然后提供 一些可靠数据传输的机制，如果数据包加上TCP头大于MSS(最大报 文段长度)就会进行TCP分片，主要协议有TCP，UDP； 

5网络层：网络层的主要作用就是网络寻址以及分片，如果 IP头加上报文段的长度大于MTU，则需要进行分片处理，主要协议 有IP和ICMP； 

6.数据链路层：数据链路层的主要作用物理寻址，提供字节 和比特的相互转换，主要协议有ARP； 

7. 物理层：作用就是定义了传输介质的标准；
